# Global Indicator Project - proposed indicator discussion

## 1. Walkability (z-scores for local neigborhood dwelling density, street connectivity and daily living score) 
#### Carl's thoughts
If we were calculating these indicators for sample points in the first instance we could use an approach like the following:

In the notebook 'ch_custom_routing_20180824.ipynb' (which you may have accessed from the repository previously, but is just now added back in the ind_bangkok/process/sketches folder) I defined a function to calculate street connectivity for sample points based on their 1600m walkable local neighbourhood.  I believe this approach could be adapated and elaborated on to add in the other measures:

```python
# Local neighbourhood analysis
def analyse_local_nh(G, orig_point, buffer=50, length = 1600, intersection_tolerance = 15):
    # locate closest node on network to 
    orig_node = ox.get_nearest_node(G, orig_point, return_dist=True)
    subgraph = nx.ego_graph(G, orig_node[0], radius=length, distance='length')
    # We project the subgraph to UTM so we can use metres as a unit when buffering
    subgraph = ox.project_graph(subgraph)
    su = ox.graph_to_gdfs(subgraph, nodes=False, edges=True, fill_edge_geometry=True)
    bu = su.geometry.buffer(buffer)
    uu = bu.geometry.unary_union
    area_sqm = uu.area
    area_sqkm = area_sqm*1e-06
    stats = ox.basic_stats(subgraph, area=area_sqm, clean_intersects=True, tolerance=intersection_tolerance,
                circuity_dist='euclidean')
    return({'graph': subgraph,
             'network_gdfs':su,
             'buffer':uu,
             'area_sqkm':area_sqkm,
             'stats':stats,
             'origin_node_snap_dist': orig_node[1]})
     
# Define some point locations over which we'll iterate
point_locations = [(-37.808156, 144.964942),(-37.764727, 144.964057)]
# initialise an 
nh_estimates = []

for point in point_locations:
  start = time.time()
  task = "Calculate local neighbourhood measures for points"
  nh_estimates.append(analyse_local_nh(G, point))
  log('Completed task "{}" in {:,.2f} seconds'.format(task,time.time() - start)) 
  
# Get some stats
## area in sqkm
[x['area_sqkm'] for x in nh_estimates]

## intersection density per sqkm
[x['stats']['intersection_density_km'] for x in nh_estimates]

## clean intersection density per sqkm
[x['stats']['clean_intersection_density_km'] for x in nh_estimates]
```
So, that makes use of the osmnx stats functionality for calculating street connectivity.  

The use of the function might be overkill; assuming we have a dataframe of sample points, if you coded it right there might even be a vectorised solution to carry out the operations, like extracting the 50m buffered unary union of 1600m network linestrings for a sample point as a geometry field and then use intersection analysis for each sample point's network buffer polygon with other pre-prepared resources:

- use population raster (eg worldpop, or other) to derive a scaled-population density measure to serve as a proxy measure for dwelling density (e.g. take sum of population cells intersecting sausage buffer and divide by some indicative number for population per dwelling (e.g. 4) then standardise that result by dividing by the area of the sausage buffer in Hectares  --- so a result a-bit like dwellings per hectare (although technically, it isn't that.... i'm not saying this is valid, but it could be done and might serve for this purpose)

- count clean network intersections generated by osmnx which intersect a sample point's sausage buffer and divide by area in km2 for street connectivity per square kilometre

- if we pre-extract a series of destination POIs grouped into something like (pending discussion on how to translate this globally) 'supermarkets', 'convenience', 'public transport stops' (the latter from GTFS analysis - possibly restricted to those with 'frequent' service) then calculate a score for each sausage buffer based on presence of at least one from each category.

Then, once you have a dataframe with rows per sample points with each associated with the above measures we could calculate their respective z-scores as per [this post](https://stackoverflow.com/questions/24761998/pandas-compute-z-score-for-all-columns) you could do something like

```python
indicators = ['dd_nh1600m','sc_nh1600m','dl_nh1600m']
nh_zscores = list()
for col in indicators
    z = 'z_{}'.format(col)
    df[z] = (df[col] - df[col].mean())/df[col].std(ddof=0)
    nh_zscores.append(z)

df['walkability'] = =df.loc[:,nh_zscores].sum(axis=1)
```
Then, summary statistics for small administrative areas, regular grid squares or hexagons can be calculated --- e.g. mean, sd, min, max, p25, p50, p75, as well as for the study region as a whole

We then have average walkability for a given small area (be it an administrative area, or some standard area we use for all regions -- like hexagon for a hexbin plot) and can also see how it varies not only across areas but also within areas (if areas are reasonably, we would expect not much variation amongst the sample points).

If we use the Pandanas approach, that could be worked in using similar to the above - ie. evaluate ```df['daily_living']``` based on the pandanas accessibility analysis. And similar for other measures if alternatives are taken.

This dataframe approach could be applied for other analyses too.  If data starts getting a bit too big, we could move to using postgresql (as was floated for GTFS analysis anyway).  Postgis can work well with Geopandas, and I have code examples for sharing data back and forth between the two environments.

### street connectivity
- cleaned intersections (the number of cleaned intersections of pedestrain network/total area)

### dwelling density 
- standardized ratio of people or housing units within the city
- the number of dwellings within local walkable neighborhood/total area

### land use mix/daily living scores
- % of land use allocated to residential, retail, civic and institutional, entertainment, recreation, food-related (can we get the land use data?)
- access to POIs (e.g. convenience, supermarket, and public transport stop)
	- using the sausage buffer technique and binary measures =1 for at least one POI within the walkable neighborhood, =0 for no POI within the walkable neighborhood
	- using the [pandana approach](https://github.com/gboeing/urban-data-science/blob/59afcff905649c5f8d1f8256ec37f28496e0c740/20-Accessibility-Walkability/pandana-accessibility-demo-full.ipynb) for network accessibility and walkability analysis: nearest distance to POIs. 


** local walkable neighborhood: a 1600m walkable network buffered around pedestrain street  
** residentail neighborhood: 1600m pedestrain network buffer around residential addresses.   
** Buffering technique referring to Forsyth et al [here](https://ij-healthgeographics.biomedcentral.com/articles/10.1186/1476-072X-11-14). Mavoa et al 2018, see [here](https://www.jtlu.org/index.php/jtlu/article/view/1132)  



## 2. Transport
### Access to any public transport
- % of population within mode specific distance to any public transport
- % of population to any frequent public transport within mode specific distance (how to define frequent transport - serviced every ? minutes on a normal day)

### Road and pedestrian network ratio
- Full road network (km) to pedestrian network (km)

## 3. Employment
### Access to employment
- % of population within 30 mins of home by walking
- % of population within 30 mins of home by cycling
- % of population within 30 mins of home by public transport

### Employment ratio
- Employed persons to working population

### Commute Distance
- Median commute distance for area


## 4. Density
### Access to places
- % of population within 1.2km of activity centres
- % of population within 1.2km of public transport hubs
- % of population within 1.2km of urban fringe developments

- % of urban fringe population within 1.2km of activity centres and public transport hubs
- % of non-urban fringe population within 1.2km of activity centres and public transport hubs

## 5. Destinations


## 6. Open space
- % of land area allocated to open space
- % of population access to public open space
